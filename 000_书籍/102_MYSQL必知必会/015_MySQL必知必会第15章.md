---
title: MySQL必知必会15-20章
date: 2020-08-17 14:23:53
tags:
  - MySQL
  - MYSQL必知必会
---

这些章讲解联结表，组合查询，全文本搜索，插入数据，更新和删除数据。

<!--more-->

## 第十五章，联结表

### 15.1.联结

联结是利用SELECT能执行的最重要的操作，在有效地使用联结前，必须了解关系表以及关系数据库设计的一些基础知识。

#### 15.1.1.关系表

理解关系表的最好办法是来看一个现实世界中的例子。

假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。

现在，假如有同一供应商生产的多种物品，那么在何处存储供应商信息(如，供应商名，地址，联系方法等)呢？将这些数据与产品信息分开存储的理由如下：

1.因为同一个供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息即浪费时间又浪费存储空间。

2.如果供应商信息改变(例如，供应商搬家或电话号码变动)，值需改动一次即可。

3.如果有重复数据(即每种产品都存储供应商信息)，很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。

关键是，相同数据出现多次绝不是一件好事，此因素是关系数据库设计的基础。关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值(即关系设计中的关系)互相关联。

在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。vendors表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为主键，可以是供应商ID或任何其他唯一值。

products表只存储产品信息，它除了存储供应商ID(vendors的主键)外不存其他供应商信息。vendors表又叫作products表的外键，它将vendors表和products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。

**外键(foregin key)：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。**

这样做的好处如下：

1.供应商信息不重复，从而不浪费时间和空间。

2.如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动

3.由于数据无重复，显然数据是一致的，这使得处理数据更简单。

总之，关系数据库的可伸缩性远比非关系数据库要好。

**可伸缩性：能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好。**

#### 15.1.2.为什么要使用联结

分解数据更能有效地存储，更方便处理，并且有着更大的可伸缩性。但这些好处是有代价的。

如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？答案是使用联结。简单的说，联结是一种机制，用来在一条SELLECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。

### 15.2.创建联结

联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。看下面的例子。

```mysql
输入：  SELECT  vend_name, prod_name,prod_price
       FROM   vendors, products
       WHERE  vendors.vend_id = products.vend_id
       ORDER BY vend_name, prod_name
```

输出：

| vend_name | prod_name | prod_price |
| --------- | --------- | ---------- |
| ACME      | Bird      | 10.00      |
| ACME      | Carr      | 2.50       |

分析：这里的语句与前面的大致相同。这里，最大的差别是所指定的两个列(prod_name和prod_price)在一个表中，而另一个列(_name)在另一个表中。

现在来看FROM子句。与之前的SELECT子句不一样，这条语句的FROM子句列出了两个表，它们就是这条SELECT语句联结的两个表的名字。这两个表用WHERE子句正确联结，WHERE子句指示MySQL匹配vendors表中的vend_id和products表中的vend_id。

可以看到要匹配的两个列以vendors.vend_id和products.vend_id指定。这里需要这种完全限定列名，因为如果只给出vend_id，则MySQL不知道指的是哪一个(它们有两个，一个表一个)。

**笛卡儿积：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。**

**不要忘了WHERE子句：应该保证所有联结都有WHERE子句，否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。不正确的过滤条件将导致MySQL返回不正确的数据。**

#### 15.2.2.内部联结

目前为止所用的联结称为等值联结，它基于两个表之间的相等测试。这种联结也称为内部联结。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。下面的SELECT语句返回与前面例子完全相同的数据。

```mysql
输入：  SELECT  vend_name, prod_name,prod_price
       FROM   vendors INNER  JOIN products
       ON vendors.vend_id = products.vend_id;
```

分析：此语句中的SELECT与前面的SELECT语句相同，但FROM子句不同。这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。

**使用哪种语言：SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。**

#### 15.2.3.联结多个表

SQL对SELECT语句可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。